/**
 * 1.不可变的对象应该被重用！尤其是使用该对象的语句在循环体或者被频繁调用的方法中时。
 *  比如字符串类型String，就维护了自己的字符串池(String Pool).通过双引号间的常量，
 *  先查找字符串池中有没有对应已创建好的字符串，没有才会新建实例，并保存到字符串池中。
 *
 * 2.已知不会被修改的可变对象也应该被重用！{@link Person}里面有关于这一点的说明，
 *  检测是否在生育高峰期出生时，起止时间日期一旦被计算出来就不会被更改，这时候考虑重用
 *
 * 3.有些情况并不是那么显然，比如适配器adapter，它只是为后备对象提供一个可以替代的接口，
 *  由于除了后备对象外，adapter没有其他状态信息，因此对于给定对象的特定适配器，
 *  不需要创建多个适配器实例。
 *    ?:适配器:对象 是1:1还是1：n?——1:n。因为相同的数据集对应了相同的后备对象，
 *    但它们之间的适配规则是不变的，所以只需要一个适配器，就可以对所有同类的对象进行适配。
 *
 * 4.警惕无意识的自动装箱&拆箱带来的性能损失。比如下面的例子{@link #addAll()}和
 * {@link #badAddAll()}, 两者运行时打印出结果所用时间差距非常明显，
 * 这是badAddall()中误把基本类型long写成基本装箱类型Long导致。
 *
 * *.但是这并不是想表示“创建对象代价昂贵，我们应该避免创建对象”，相反，
 *  由于小型对象构造器只做很少量显式工作，因而它们的创建和回收特别廉价。
 *  通过创建附加的对象，提升程序的清晰性、简洁性和功能性，通常是件好事;
 *
 * **.相反，通过维护自己的对象池来避免创建对象可能并不是一种很好的做法，
 *  除非池中的对象是非常重量级的。举一个使用得当的例子：数据库连接池，
 *  建立数据库连接的代价是非常昂贵的，而且建立数据库连接的数量往往被数据库所限制，
 *  因此重用这些对象非常有意义。但是一般而言，维护自己的对象池往往会把代码搞乱，
 *  增加内存占用，损害性能。现在高度优化的JVM GC性能很容易就会超过轻量级对象池。
 *
 * ***.与本条对应的是“保护性拷贝”————“当你应该重新创建对象时，请不要重用现有的对象”。
 *  需要使用保护性拷贝的时候，因重用对象付出的代价应远远高于创建重复对象。比如，
 *  如果不实行保护性拷贝会导致潜在的错误或安全漏洞，
 *  而不必要的创建对象只会影响程序的风格和性能时。
 *
 * @author LightDance
 */
public class ReuseImmutableObject {

    private static void badAddAll(){
        Long sum = 0L;
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i;
        }
        System.out.println(sum);
    }

    private static void addAll(){
        long sum = 0L;
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i;
        }
        System.out.println(sum);
    }

    public static void main(String[] args) {
        //badAddAll();
        addAll();
    }
}
